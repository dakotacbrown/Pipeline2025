envs:
  dev:
    base_url: "https://api.vendor-a.com/"
  qa:
    base_url: "https://finance.example.com/api/"
  prod:
    base_url: "https://yourinstance.my.salesforce.com/"   # fill in

apis:
  # ---------------------------
  # GLOBAL DEFAULTS
  # ---------------------------
  request_defaults:                 # passed to requests.get(**kwargs)
    headers:
      Authorization: "Bearer ${VENDOR_A_TOKEN}"   # resolved at runtime if you expand env vars
      Accept: "application/json"
    timeout: 60
    verify: true

  # Root-level defaults used by many tables (your code reads these)
  path: "services/data/v61.0/query"              # default resource (Salesforce SOQL endpoint)
  retries:                                       # session-level retry config (HTTPAdapter)
    total: 4
    backoff_factor: 0.5
    status_forcelist: [429, 500, 502, 503, 504]
    allowed_methods: ["GET"]

  pagination:                                    # default paginator is Salesforce-style
    mode: "salesforce"
    done_path: "done"
    next_url_path: "nextRecordsUrl"              # relative path returned by Salesforce
    clear_params_on_next: true                   # drop ?q=... after first call
    max_pages: 20000

  link_expansion:                                # global link expansion defaults (can be overridden per table)
    enabled: true
    url_fields: ["detail_url", "links.self"]     # dot paths to URL fields in the *row*
    json_record_path: null                       # override record path for expanded payloads (optional)
    per_request_delay: 0.0

  # =========================================================
  # 1) SALESFORCE + SOQL WINDOWED BACKFILL (pagination: salesforce | backfill: soql_window)
  # =========================================================
  marketing_reports:
    # Parsing Salesforce JSON list at "records" and drop noisy "attributes" everywhere
    parse:
      type: "json"
      json_record_path: "records"
      json_drop_keys_any_depth: ["attributes"]

    # (Optional) parameters for one-off runs; for backfill, q is built from soql_template below
    # params:
    #   q: "SELECT Id, Name FROM Account ORDER BY LastModifiedDate ASC"

    backfill:
      enabled: true
      strategy: "soql_window"                    # special Salesforce backfill mode
      date_field: "LastModifiedDate"             # or "SystemModstamp"
      date_format: "%Y-%m-%dT%H:%M:%SZ"
      window_days: 7                             # half-open windows: [start, end)
      per_request_delay: 0.0
      soql_template: |
        SELECT Id, Name, LastModifiedDate
        FROM Account
        WHERE {date_field} >= {start}
          AND {date_field} <  {end}
        ORDER BY {date_field} ASC

  # =========================================================
  # 2) GENERIC DATE WINDOWED BACKFILL + PAGE PAGINATION (pagination: page | backfill: date)
  # =========================================================
  events_api:                         # table-specific path (if your _prepare supports table overrides)
    parse:
      type: "json"
      json_record_path: "data.items"

    # Page-based pagination (page, page_size)
    pagination:
      mode: "page"
      page_param: "page"
      start_page: 1
      page_size_param: "page_size"
      page_size_value: 500
      max_pages: 10000

    # Generic date-window backfill with custom param names and date format
    backfill:
      enabled: true
      strategy: "date"
      start_param: "start_date"
      end_param: "end_date"
      date_format: "%Y-%m-%d"                    # e.g., 2025-09-30
      window_days: 3
      per_request_delay: 0.0

  # =========================================================
  # 3) CURSOR PAGINATION WITH OPAQUE NEXT TOKEN + CURSOR BACKFILL
  #    (pagination: cursor using next_cursor_path | backfill: cursor)
  # =========================================================
  activity_feed:
    parse:
      type: "json"
      json_record_path: "results"

    pagination:
      mode: "cursor"
      cursor_param: "cursor"                     # query param name to send
      next_cursor_path: "meta.next"              # where to read next token in the response body
      page_size_param: "limit"
      page_size_value: 1000
      max_pages: 50000

    backfill:
      enabled: true
      strategy: "cursor"
      cursor:
        # Start from a known checkpoint cursor (optional). If omitted, starts from the first page.
        start_value: null
        # Stop when we reach data older than this timestamp (ISO 8601) on the given field:
        stop_when_older_than:
          field: "created_at"
          value: "2025-01-01T00:00:00Z"

  # =========================================================
  # 4) CURSOR PAGINATION BY CHAINING LAST ID (chain_field) + CURSOR BACKFILL
  #    (pagination: cursor using chain_field | backfill: cursor)
  # =========================================================
  issues_stream:
    parse:
      type: "json"
      json_record_path: "items"

    pagination:
      mode: "cursor"
      cursor_param: "after_id"                   # send ?after_id=<last id from previous page>
      chain_field: "id"                          # take last id from each page to form next cursor
      page_size_param: "limit"
      page_size_value: 1000
      max_pages: 200000

    backfill:
      enabled: true
      strategy: "cursor"
      cursor:
        # Stop at a specific item id (useful for bounded replays)
        stop_at_item:
          field: "id"
          value: "1234567890"
          inclusive: false

  # =========================================================
  # 5) LINK-HEADER PAGINATION (RFC 5988 rel="next")
  # =========================================================
  link_header_api:
    parse:
      type: "json"
      json_record_path: "data"
    pagination:
      mode: "link-header"                        # follow Response.headers['Link'] rel="next"
      max_pages: 10000
    backfill:
      enabled: false

  # =========================================================
  # 6) NO PAGINATION (single request) + LINK EXPANSION
  # =========================================================
  orders_with_details:
    parse:
      type: "json"
      json_record_path: "orders"

    # No pagination: single shot
    pagination:
      mode: "none"

    # Follow URLs embedded in each row to pull detailed payloads
    link_expansion:
      enabled: true
      url_fields: ["detail_url", "links.detail"] # row fields that contain absolute URLs
      json_record_path: null                     # if the expanded payload is already a list, leave null
      per_request_delay: 0.0

    backfill:
      enabled: false

  # =========================================================
  # 7) CSV EXAMPLE (no backfill)
  # =========================================================
  finance_exports:
    parse:
      type: "csv"
    pagination:
      mode: "none"
    backfill:
      enabled: false
    # Optionally disable link expansion for CSV if global enabled:
    # link_expansion:
    #   enabled: false
